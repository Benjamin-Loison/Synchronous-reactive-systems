!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/sofamaniac/Nextcloud/cours/M2/synchronous_systems/project/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20220828.0/
ARROW	src/_build/parser.ml	/^  | ARROW$/;"	C	type:token
ARROW	src/_build/parser.mli	/^  | ARROW$/;"	C	type:token
Ast	src/_build/ast.ml	/^type ident = string$/;"	M
Ast	src/ast.ml	/^exception MyTypeError of string$/;"	M
BOOL	src/_build/parser.ml	/^  | BOOL$/;"	C	type:token
BOOL	src/_build/parser.mli	/^  | BOOL$/;"	C	type:token
BO_and	src/_build/parser.ml	/^  | BO_and$/;"	C	type:token
BO_and	src/_build/parser.mli	/^  | BO_and$/;"	C	type:token
BO_div	src/_build/parser.ml	/^  | BO_div$/;"	C	type:token
BO_div	src/_build/parser.mli	/^  | BO_div$/;"	C	type:token
BO_ge	src/_build/parser.ml	/^  | BO_ge$/;"	C	type:token
BO_ge	src/_build/parser.mli	/^  | BO_ge$/;"	C	type:token
BO_gt	src/_build/parser.ml	/^  | BO_gt$/;"	C	type:token
BO_gt	src/_build/parser.mli	/^  | BO_gt$/;"	C	type:token
BO_le	src/_build/parser.ml	/^  | BO_le$/;"	C	type:token
BO_le	src/_build/parser.mli	/^  | BO_le$/;"	C	type:token
BO_lt	src/_build/parser.ml	/^  | BO_lt$/;"	C	type:token
BO_lt	src/_build/parser.mli	/^  | BO_lt$/;"	C	type:token
BO_mod	src/_build/parser.ml	/^  | BO_mod$/;"	C	type:token
BO_mod	src/_build/parser.mli	/^  | BO_mod$/;"	C	type:token
BO_mul	src/_build/parser.ml	/^  | BO_mul$/;"	C	type:token
BO_mul	src/_build/parser.mli	/^  | BO_mul$/;"	C	type:token
BO_neq	src/_build/parser.ml	/^  | BO_neq$/;"	C	type:token
BO_neq	src/_build/parser.mli	/^  | BO_neq$/;"	C	type:token
BO_or	src/_build/parser.ml	/^  | BO_or$/;"	C	type:token
BO_or	src/_build/parser.mli	/^  | BO_or$/;"	C	type:token
BOp_add	src/_build/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_add	src/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_and	src/_build/ast.ml	/^  | BOp_and | BOp_or | BOp_eq | BOp_neq$/;"	C	type:binop
BOp_and	src/ast.ml	/^  | BOp_and | BOp_or | BOp_arrow$/;"	C	type:binop
BOp_arrow	src/ast.ml	/^  | BOp_and | BOp_or | BOp_arrow$/;"	C	type:binop
BOp_div	src/_build/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_div	src/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_eq	src/_build/ast.ml	/^  | BOp_and | BOp_or | BOp_eq | BOp_neq$/;"	C	type:binop
BOp_ge	src/_build/ast.ml	/^  | BOp_le | BOp_lt | BOp_ge | BOp_gt$/;"	C	type:binop
BOp_gt	src/_build/ast.ml	/^  | BOp_le | BOp_lt | BOp_ge | BOp_gt$/;"	C	type:binop
BOp_le	src/_build/ast.ml	/^  | BOp_le | BOp_lt | BOp_ge | BOp_gt$/;"	C	type:binop
BOp_lt	src/_build/ast.ml	/^  | BOp_le | BOp_lt | BOp_ge | BOp_gt$/;"	C	type:binop
BOp_mod	src/_build/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_mod	src/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_mul	src/_build/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_mul	src/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_neq	src/_build/ast.ml	/^  | BOp_and | BOp_or | BOp_eq | BOp_neq$/;"	C	type:binop
BOp_or	src/_build/ast.ml	/^  | BOp_and | BOp_or | BOp_eq | BOp_neq$/;"	C	type:binop
BOp_or	src/ast.ml	/^  | BOp_and | BOp_or | BOp_arrow$/;"	C	type:binop
BOp_sub	src/_build/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BOp_sub	src/ast.ml	/^  | BOp_add | BOp_sub | BOp_mul | BOp_div | BOp_mod$/;"	C	type:binop
BVar	src/ast.ml	/^  | BVar of ident$/;"	C	type:t_var
CBool	src/_build/ast.ml	/^  | CBool of bool$/;"	C	type:const
CBool	src/ast.ml	/^  | CBool of bool$/;"	C	type:const
CInt	src/_build/ast.ml	/^  | CInt of int$/;"	C	type:const
CInt	src/ast.ml	/^  | CInt of int$/;"	C	type:const
COLON	src/_build/parser.ml	/^  | COLON$/;"	C	type:token
COLON	src/_build/parser.mli	/^  | COLON$/;"	C	type:token
COMMA	src/_build/parser.ml	/^  | COMMA$/;"	C	type:token
COMMA	src/_build/parser.mli	/^  | COMMA$/;"	C	type:token
CONST_BOOL	src/_build/parser.ml	/^  | CONST_BOOL of (bool)$/;"	C	type:token
CONST_BOOL	src/_build/parser.mli	/^  | CONST_BOOL of (bool)$/;"	C	type:token
CONST_INT	src/_build/parser.ml	/^  | CONST_INT of (int)$/;"	C	type:token
CONST_INT	src/_build/parser.mli	/^  | CONST_INT of (int)$/;"	C	type:token
COp_eq	src/ast.ml	/^  | COp_eq | COp_neq$/;"	C	type:compop
COp_ge	src/ast.ml	/^  | COp_le | COp_lt | COp_ge | COp_gt$/;"	C	type:compop
COp_gt	src/ast.ml	/^  | COp_le | COp_lt | COp_ge | COp_gt$/;"	C	type:compop
COp_le	src/ast.ml	/^  | COp_le | COp_lt | COp_ge | COp_gt$/;"	C	type:compop
COp_lt	src/ast.ml	/^  | COp_le | COp_lt | COp_ge | COp_gt$/;"	C	type:compop
COp_neq	src/ast.ml	/^  | COp_eq | COp_neq$/;"	C	type:compop
CReal	src/ast.ml	/^  | CReal of real$/;"	C	type:const
Calc	src/_build/calc.ml	/^open Ast$/;"	M
EApp	src/ast.ml	/^  | EApp   of full_ty * t_node * t_expression$/;"	C	type:t_expression
EBinOp	src/ast.ml	/^  | EBinOp of full_ty * binop * t_expression * t_expression$/;"	C	type:t_expression
EComp	src/ast.ml	/^  | EComp  of full_ty * compop * t_expression * t_expression$/;"	C	type:t_expression
EConst	src/ast.ml	/^  | EConst of full_ty * const$/;"	C	type:t_expression
ELSE	src/_build/parser.ml	/^  | ELSE$/;"	C	type:token
ELSE	src/_build/parser.mli	/^  | ELSE$/;"	C	type:token
EMonOp	src/ast.ml	/^  | EMonOp of full_ty * monop * t_expression$/;"	C	type:t_expression
EOF	src/_build/parser.ml	/^  | EOF$/;"	C	type:token
EOF	src/_build/parser.mli	/^  | EOF$/;"	C	type:token
EQUAL	src/_build/parser.ml	/^  | EQUAL$/;"	C	type:token
EQUAL	src/_build/parser.mli	/^  | EQUAL$/;"	C	type:token
ETriOp	src/ast.ml	/^  | ETriOp of full_ty * triop * t_expression * t_expression * t_expression$/;"	C	type:t_expression
ETuple	src/ast.ml	/^  | ETuple of full_ty * (t_expression list)$/;"	C	type:t_expression
EVar	src/ast.ml	/^  | EVar   of full_ty * t_var$/;"	C	type:t_expression
EWhen	src/ast.ml	/^  | EWhen  of full_ty * t_expression * t_expression$/;"	C	type:t_expression
FTArr	src/ast.ml	/^  | FTArr of full_ty * full_ty$/;"	C	type:full_ty
FTBase	src/ast.ml	/^  | FTBase of base_ty$/;"	C	type:full_ty
FTList	src/ast.ml	/^  | FTList of full_ty list$/;"	C	type:full_ty
IDENT	src/_build/parser.ml	/^  | IDENT of (string)$/;"	C	type:token
IDENT	src/_build/parser.mli	/^  | IDENT of (string)$/;"	C	type:token
IF	src/_build/parser.ml	/^  | IF$/;"	C	type:token
IF	src/_build/parser.mli	/^  | IF$/;"	C	type:token
INT	src/_build/parser.ml	/^  | INT$/;"	C	type:token
INT	src/_build/parser.mli	/^  | INT$/;"	C	type:token
IVar	src/ast.ml	/^  | IVar of ident$/;"	C	type:t_var
LET	src/_build/parser.ml	/^  | LET$/;"	C	type:token
LET	src/_build/parser.mli	/^  | LET$/;"	C	type:token
LPAREN	src/_build/parser.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	src/_build/parser.mli	/^  | LPAREN$/;"	C	type:token
Lexer	src/_build/lexer.ml	/^# 1 "lexer.mll"$/;"	M
Lexing_error	src/_build/lexer.ml	/^  exception Lexing_error of string$/;"	e
MINUS	src/_build/parser.ml	/^  | MINUS$/;"	C	type:token
MINUS	src/_build/parser.mli	/^  | MINUS$/;"	C	type:token
MO_not	src/_build/parser.ml	/^  | MO_not$/;"	C	type:token
MO_not	src/_build/parser.mli	/^  | MO_not$/;"	C	type:token
MOp_minus	src/_build/ast.ml	/^  | MOp_minus$/;"	C	type:monop
MOp_minus	src/ast.ml	/^  | MOp_not | MOp_minus | MOp_pre$/;"	C	type:monop
MOp_not	src/_build/ast.ml	/^  | MOp_not$/;"	C	type:monop
MOp_not	src/ast.ml	/^  | MOp_not | MOp_minus | MOp_pre$/;"	C	type:monop
MOp_pre	src/ast.ml	/^  | MOp_not | MOp_minus | MOp_pre$/;"	C	type:monop
Main	src/main.ml	/^open Ast$/;"	M
MyTypeError	src/ast.ml	/^exception MyTypeError of string$/;"	e
NODE	src/_build/parser.ml	/^  | NODE$/;"	C	type:token
NODE	src/_build/parser.mli	/^  | NODE$/;"	C	type:token
PE_BinOp	src/_build/ast.ml	/^  | PE_BinOp of binop * p_expression * p_expression$/;"	C	type:p_expression
PE_Const	src/_build/ast.ml	/^  | PE_Const of const$/;"	C	type:p_expression
PE_MonOp	src/_build/ast.ml	/^  | PE_MonOp of monop * p_expression$/;"	C	type:p_expression
PE_TriOp	src/_build/ast.ml	/^  | PE_TriOp of triop * p_expression * p_expression * p_expression$/;"	C	type:p_expression
PE_Var	src/_build/ast.ml	/^  | PE_Var of ident$/;"	C	type:p_expression
PE_app	src/_build/ast.ml	/^  | PE_app of ident * p_expression list$/;"	C	type:p_expression
PE_arrow	src/_build/ast.ml	/^  | PE_arrow of p_expression * p_expression$/;"	C	type:p_expression
PE_pre	src/_build/ast.ml	/^  | PE_pre of p_expression$/;"	C	type:p_expression
PE_tuple	src/_build/ast.ml	/^  | PE_tuple of p_expression list$/;"	C	type:p_expression
PLUS	src/_build/parser.ml	/^  | PLUS$/;"	C	type:token
PLUS	src/_build/parser.mli	/^  | PLUS$/;"	C	type:token
PP_tuple	src/_build/ast.ml	/^  | PP_tuple of ident list$/;"	C	type:p_pattern
PP_var	src/_build/ast.ml	/^  | PP_var of ident$/;"	C	type:p_pattern
PRE	src/_build/parser.ml	/^  | PRE$/;"	C	type:token
PRE	src/_build/parser.mli	/^  | PRE$/;"	C	type:token
Parser	src/_build/parser.ml	/^type token =$/;"	M
Parser	src/_build/parser.mli	/^type token =$/;"	M
Pp	src/_build/pp.ml	/^open Ast$/;"	M
Pp	src/pp.ml	/^open Ast$/;"	M
RETURNS	src/_build/parser.ml	/^  | RETURNS$/;"	C	type:token
RETURNS	src/_build/parser.mli	/^  | RETURNS$/;"	C	type:token
RPAREN	src/_build/parser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	src/_build/parser.mli	/^  | RPAREN$/;"	C	type:token
RVar	src/ast.ml	/^  | RVar of ident$/;"	C	type:t_var
SEMICOL	src/_build/parser.ml	/^  | SEMICOL$/;"	C	type:token
SEMICOL	src/_build/parser.mli	/^  | SEMICOL$/;"	C	type:token
TBool	src/ast.ml	/^  | TBool$/;"	C	type:base_ty
TEL	src/_build/parser.ml	/^  | TEL$/;"	C	type:token
TEL	src/_build/parser.mli	/^  | TEL$/;"	C	type:token
THEN	src/_build/parser.ml	/^  | THEN$/;"	C	type:token
THEN	src/_build/parser.mli	/^  | THEN$/;"	C	type:token
TInt	src/ast.ml	/^  | TInt$/;"	C	type:base_ty
TOp_if	src/_build/ast.ml	/^  | TOp_if$/;"	C	type:triop
TOp_if	src/ast.ml	/^  | TOp_if | TOp_merge$/;"	C	type:triop
TOp_merge	src/ast.ml	/^  | TOp_if | TOp_merge$/;"	C	type:triop
TReal	src/ast.ml	/^  | TReal$/;"	C	type:base_ty
Tbool	src/_build/ast.ml	/^  | Tbool$/;"	C	type:base_ty
Tint	src/_build/ast.ml	/^  | Tint$/;"	C	type:base_ty
Utils	src/utils.ml	/^let rec list_repeat n elt =$/;"	M
VAR	src/_build/parser.ml	/^  | VAR$/;"	C	type:token
VAR	src/_build/parser.mli	/^  | VAR$/;"	C	type:token
_	src/_build/calc.ml	/^let _ =$/;"	f
_	src/_build/parser.ml	/^let _ = parse_error;;$/;"	f
_	src/main.ml	/^let _ =$/;"	f
__ocaml_lex_tables	src/_build/lexer.ml	/^let __ocaml_lex_tables = {$/;"	f
__ocaml_lex_token_rec	src/_build/lexer.ml	/^and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =$/;"	f
all	Makefile	/^all:$/;"	t
all	src/Makefile	/^all:$/;"	t
base_ty	src/_build/ast.ml	/^type base_ty =$/;"	t
base_ty	src/ast.ml	/^type base_ty =$/;"	t
binop	src/_build/ast.ml	/^type binop =$/;"	t
binop	src/ast.ml	/^type binop =$/;"	t
check_dependencies	src/main.ml	/^let check_dependencies (a: t_nodelist) = Some a$/;"	f
check_well_formedness	src/main.ml	/^let check_well_formedness (a: t_nodelist) = Some a$/;"	f
clean	Makefile	/^clean:$/;"	t
clean	src/Makefile	/^clean:$/;"	t
compop	src/ast.ml	/^type compop =$/;"	t
const	src/_build/ast.ml	/^type const =$/;"	t
const	src/ast.ml	/^type const =$/;"	t
current_location	src/_build/parser.ml	/^  let current_location () = symbol_start_pos (), symbol_end_pos ()$/;"	f
exit_error	src/main.ml	/^let exit_error (s: string) : unit =$/;"	f
full_ty	src/ast.ml	/^type full_ty =$/;"	t
id_or_keywork	src/_build/lexer.ml	/^  let id_or_keywork =$/;"	v
ident	src/_build/ast.ml	/^type ident = string$/;"	t
ident	src/ast.ml	/^type ident = string$/;"	t
list_repeat	src/utils.ml	/^let rec list_repeat n elt =$/;"	f
location	src/_build/ast.ml	/^type location = Lexing.position * Lexing.position$/;"	t
location	src/ast.ml	/^type location = Lexing.position * Lexing.position$/;"	t
main	src/_build/parser.ml	/^let main (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =$/;"	f
main	src/_build/parser.mli	/^val main :$/;"	p	type:token
monop	src/_build/ast.ml	/^type monop =$/;"	t
monop	src/ast.ml	/^type monop =$/;"	t
n_equations	src/ast.ml	/^    n_equations: t_eqlist;$/;"	r	type:t_node
n_inputs	src/ast.ml	/^    n_inputs: t_varlist;$/;"	r	type:t_node
n_local_vars	src/ast.ml	/^    n_local_vars: t_varlist;$/;"	r	type:t_node
n_name	src/ast.ml	/^    n_name : ident;$/;"	r	type:t_node
n_outputs	src/ast.ml	/^    n_outputs: t_varlist;$/;"	r	type:t_node
n_type	src/ast.ml	/^    n_type : full_ty;$/;"	r	type:t_node
p_equation	src/_build/ast.ml	/^type p_equation =$/;"	t
p_expression	src/_build/ast.ml	/^type p_expression =$/;"	t
p_node	src/_build/ast.ml	/^type p_node =$/;"	t
p_pattern	src/_build/ast.ml	/^type p_pattern =$/;"	t
p_prog	src/_build/ast.ml	/^type p_prog = p_node list$/;"	t
peq_expr	src/_build/ast.ml	/^    peq_expr: p_expression }$/;"	r	type:p_equation
peq_patt	src/_build/ast.ml	/^  { peq_patt: p_pattern;$/;"	r	type:p_equation
pn_equations	src/_build/ast.ml	/^    pn_equations:  p_equation list;$/;"	r	type:p_node
pn_input	src/_build/ast.ml	/^    pn_input:      (ident * base_ty) list;$/;"	r	type:p_node
pn_loc	src/_build/ast.ml	/^    pn_loc:        location; }$/;"	r	type:p_node
pn_local_vars	src/_build/ast.ml	/^    pn_local_vars: (ident* base_ty) list;$/;"	r	type:p_node
pn_name	src/_build/ast.ml	/^  { pn_name:       ident;$/;"	r	type:p_node
pn_output	src/_build/ast.ml	/^    pn_output:     (ident * base_ty) list;$/;"	r	type:p_node
pp_ast	src/pp.ml	/^let pp_ast fmt prog =$/;"	f
pp_equations	src/_build/pp.ml	/^let rec pp_equations fmt eqs =$/;"	f
pp_equations	src/pp.ml	/^let rec pp_equations fmt: t_eqlist -> unit = function$/;"	f
pp_expression	src/_build/pp.ml	/^let pp_expression =$/;"	v
pp_expression	src/pp.ml	/^let pp_expression =$/;"	v
pp_loc	src/_build/pp.ml	/^let pp_loc fmt (start, stop) =$/;"	f
pp_loc	src/pp.ml	/^let pp_loc fmt (start, stop) =$/;"	f
pp_node	src/pp.ml	/^let pp_node fmt node =$/;"	f
pp_node_vars	src/_build/pp.ml	/^let rec pp_node_vars fmt vars =$/;"	f
pp_nodes	src/_build/pp.ml	/^let rec pp_nodes fmt nodes =$/;"	f
pp_nodes	src/pp.ml	/^let rec pp_nodes fmt nodes =$/;"	f
pp_pattern	src/_build/pp.ml	/^let pp_pattern fmt pat =$/;"	f
pp_prog	src/_build/pp.ml	/^let pp_prog fmt prog =$/;"	f
pp_varlist	src/pp.ml	/^let rec pp_varlist fmt : t_varlist -> unit = function$/;"	f
print_debug	src/main.ml	/^let print_debug d s =$/;"	f
print_verbose	src/main.ml	/^let print_verbose v s =$/;"	f
real	src/ast.ml	/^type real = float$/;"	t
run	src/main.ml	/^let run verbose debug (passes: (t_nodelist -> t_nodelist option) list)$/;"	f
simplify_prog	src/main.ml	/^let simplify_prog (a: t_nodelist) = Some a$/;"	f
t_eqlist	src/ast.ml	/^and t_eqlist = t_equation list$/;"	t
t_equation	src/ast.ml	/^and t_equation = t_varlist * t_expression$/;"	t
t_expression	src/ast.ml	/^type t_expression =$/;"	t
t_node	src/ast.ml	/^and t_node =$/;"	t
t_nodelist	src/ast.ml	/^type t_nodelist = t_node list$/;"	t
t_var	src/ast.ml	/^type t_var =$/;"	t
t_varlist	src/ast.ml	/^and t_varlist = full_ty * (t_var list)$/;"	t
token	src/_build/lexer.ml	/^let rec token lexbuf =$/;"	f
token	src/_build/parser.ml	/^type token =$/;"	t
token	src/_build/parser.mli	/^type token =$/;"	t
triop	src/_build/ast.ml	/^type triop =$/;"	t
triop	src/ast.ml	/^type triop =$/;"	t
yyact	src/_build/parser.ml	/^let yyact = [|$/;"	v
yycheck	src/_build/parser.ml	/^let yycheck = "\\046\\000\\$/;"	v
yydefred	src/_build/parser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydgoto	src/_build/parser.ml	/^let yydgoto = "\\002\\000\\$/;"	v
yygindex	src/_build/parser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yylen	src/_build/parser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylhs	src/_build/parser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yynames_block	src/_build/parser.ml	/^let yynames_block = "\\$/;"	v
yynames_const	src/_build/parser.ml	/^let yynames_const = "\\$/;"	v
yyrindex	src/_build/parser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yysindex	src/_build/parser.ml	/^let yysindex = "\\002\\000\\$/;"	v
yytable	src/_build/parser.ml	/^let yytable = "\\058\\000\\$/;"	v
yytables	src/_build/parser.ml	/^let yytables =$/;"	v
yytablesize	src/_build/parser.ml	/^let yytablesize = 319$/;"	v
yytransl_block	src/_build/parser.ml	/^let yytransl_block = [|$/;"	v
yytransl_const	src/_build/parser.ml	/^let yytransl_const = [|$/;"	v
